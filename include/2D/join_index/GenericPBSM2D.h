/*
 * Copyright 2012 Cornell Database Group
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef _GENERIC_PBSM_2D_H_
#define _GENERIC_PBSM_2D_H_

#include "2D/StaticSpatialJoin2D.h"
#include "2D/join_index/GenericPlaneSweep2D.h"
#include "2D/join_index/plane_sweep/ListSweep.h"
#include "2D/join_index/plane_sweep/SweepStructure.h"
#include <deque>

#define DEFAULT_TILE_DIM 6

namespace PSimIndex {

    /*
     * TODO: Can we remove one of getQueryCover/setBaseCover??
     */
    template<typename U, typename K, typename A, typename RG>
    class GenericPBSM2D : public StaticSpatialJoin2D<U, K, A, RG> {
    private:
        typedef Region2D<typename K::KeyType0, typename K::KeyType1> RType;
        std::vector<U*>* baseAgents;
        SweepStructure<U,K>* sweepStructure;

        RType baseCover;
        int tileDim;
        int numPartitions;

        char name[200];

    public:

        static const char* getClassName() { return "GenericPBSM2D"; }
        const char* getInstanceName() { return name; }

        void startTick(std::vector<U*>* agents) {
            /*
             * Create a copy of the vector of pointers. These are agents,
             * which represent points. Then sort base points (and their MBRs,
             * implicitly) on x value.
             */
            baseAgents = new std::vector<U*>(*agents);

            setBaseCover();
            std::sort(baseAgents->begin(), baseAgents->end(), dim0lt<U,K>);

            typename K::KeyType1 minY = K::getKey1Max();
            typename K::KeyType1 maxY = K::getKey1Min();

            for(int i = 0; i < baseAgents->size(); i++) {
                typename K::KeyType1 key = K::getKey1(baseAgents->at(i));

                if(key < minY) {
                    minY = key;
                }

                if(key > maxY) {
                    maxY = key;
                }
            }
            sweepStructure->setMinMax(minY - 1.0, maxY + 1.0);
        }

        /**
         * Return a minimal cover of all the regions generated by rg for each
         * agent, along with all the agents themselves. Ideally this would
         * come from some catalog.
         */
        RType getQueryCover(std::vector<U*>* agents, RG* rg) {
            RType cover = rg->getRegion(*(agents->begin()));
            typename std::vector<U*>::const_iterator qIt;
            for (qIt = agents->begin(); qIt != agents->end(); qIt++) {
                U *p = *qIt;
                cover = cover.combineMBR(rg->getRegion(p));
            }
            return cover;
        }

        /**
         * Find and record the minimal cover of all the base point agents.
         */
        RType setBaseCover() {
            if (this->baseAgents->size() == 0) {
                // Invalid result, but in this case the join won't happen anyway
                return Region2D<double, double>(0, 0, 0, 0);;
            } else {
                U *first = baseAgents->front();

                RType cover = Region2D<double, double>(K::getKey0(first), 
                                                       K::getKey0(first), 
                                                       K::getKey1(first), 
                                                       K::getKey1(first));

                typename std::vector<U*>::const_iterator it;
                for (it = this->baseAgents->begin(); it != this->baseAgents->end(); it++) {
                    U *p = *it;
                    // Make a 0-area rectangle representing just the point

                    RType r = Region2D<double, double>(K::getKey0(p),
                                                       K::getKey0(p), 
                                                       K::getKey1(p), 
                                                       K::getKey1(p));


                    cover = cover.combineMBR(r);
                }
                this->baseCover = cover;
            }
            
            sweepStructure->setMinMax(baseCover.getLow1(), baseCover.getHigh1());
        }


        /**
         * Answers an enumeration query. For each query point q in agents, finds
         * the matching points among baseAgents that fall within rg->getRegion(q).
         *
         * For each point p that joins with the query point q, calls
         * cb->reportPair() on q and p.
         *
         * The query space is partitioned into a rectangular grid with tile_dim^2
         * total tiles. There are tile_dim columns and tile_dim rows in the grid.
         * Each tile is its own partition.
         */
        void enumerationJoin(JoinCallBack<K,U,U>* cb,
                             std::vector<U*>* agents,
                             RG* rg) {

            if (agents->size() == 0 || baseAgents->size() == 0) {
                return;
            }

            // Allows for the general case in which the regions represented by
            // the query agents don't necessarily span a greater space than
            // the points represented by this->baseAgents
            RType queryCover = getQueryCover(agents, rg);
            RType cover = queryCover.combineMBR(this->baseCover);

            double cover_x_width 
                = (cover.getHigh0() - cover.getLow0()) / this->tileDim;
            double cover_y_width 
                = (cover.getHigh1() - cover.getLow1()) / this->tileDim;


            typename std::vector<U*>::const_iterator bIt, qIt;
            std::deque<U*>* agentPart[numPartitions];
            std::deque<U*>* queryPart[numPartitions];



            // Initialize dequeues for parittions, which are 2D buckets for
            // the entire space.
            for (int i = 0; i < numPartitions; i++) {
                agentPart[i] = new std::deque<U*>();
                queryPart[i] = new std::deque<U*>();
            }




            std::vector<U*>* queryAgents = new std::vector<U*>(*agents);
            int numQueries = queryAgents->size();

            RType* queries = new RType[numQueries];
            
            for(int i = 0; i < numQueries; i++) {
                queries[i] = rg->getRegion(queryAgents->at(i));
            }


            //queries[numQueries] = flag;
            
            //QuerySort<U,K>::quicksort(queries, queryAgents, 0, numQueries-1);
             QuerySort<U,RType,typename K::KeyType0,&RType::low0val>
                 ::quicksort(queries, queryAgents);


            //std::sort(queryAgents->begin(), queryAgents->end(), dim0lt<U,K>);

            // Place each base point in the tile deque where it belongs.
            for (bIt = baseAgents->begin(); bIt != baseAgents->end(); bIt++) {
                U* p = *bIt;
                int xTile = (K::getKey0(p) - cover.getLow0()) / cover_x_width;
                int yTile = (K::getKey1(p) - cover.getLow1()) / cover_y_width;

                xTile = std::min(xTile, tileDim - 1);
                yTile = std::min(yTile, tileDim - 1);


                DBUTL_ASSERT((xTile >= 0 && yTile >= 0
                              && xTile < tileDim && yTile < tileDim));

                int part = (xTile * tileDim + yTile) % numPartitions;

                DBUTL_ASSERT((part >= 0 && part < numPartitions));

                agentPart[part]->push_back(p);                
            }


            // Place each query region in the tile deque(ues) where it belongs.

            // sowell: Don't use iterator to avoid problems with NULL sentinal. 
            // for (qIt = queryAgents->begin(); qIt != queryAgents->end(); qIt++) {
            for(int i = 0; i < queryAgents->size(); i++) {
                //U* p = *qIt;
                U* p = queryAgents->at(i);
                RType r = rg->getRegion(p);
                int yMax = (r.getHigh1() - cover.getLow1()) / cover_y_width;
                int yMin = (r.getLow1() - cover.getLow1()) / cover_y_width;
                int xMax = (r.getHigh0() - cover.getLow0()) / cover_x_width;
                int xMin = (r.getLow0() - cover.getLow0()) / cover_x_width;
                yMax = std::min(yMax, tileDim - 1);
                yMin = std::min(yMin, tileDim - 1);
                xMin = std::min(xMin, tileDim - 1);
                xMax = std::min(xMax, tileDim - 1);

                DBUTL_ASSERT(yMax >= yMin && yMin >= 0 && yMax < tileDim);
                DBUTL_ASSERT(xMax >= xMin && xMin >= 0 && xMax < tileDim);


                int part;
                std::deque<U*>* partList;

                for (int y = yMin; y <= yMax; y++) {
                    for (int x = xMin; x <= xMax; x++) {
                        part = (x * tileDim + y) % numPartitions;
                        partList = queryPart[part];

                        // Avoid adding a query region to the same partition
                        // more than once.
                        if(partList->size() == 0 
                           || K::getOID(partList->at(partList->size() - 1)) 
                              != K::getOID(p)) {
                            queryPart[part]->push_back(p);
                        }

                    }
                }

            }


            
            for (int i = 0; i < numPartitions; i++) {
                GenericPlaneSweep2D<U,K,A,RG>::genericPlaneSweep(
                    cb,
                    agentPart[i]->begin(),
                    agentPart[i]->end(),                    
                    queryPart[i]->begin(),
                    queryPart[i]->end(),
                    sweepStructure,
                    rg);
            }

            // Free up memory
            for (int i = 0; i < numPartitions; i++) {
                delete agentPart[i];
                delete queryPart[i];
            }
            delete queryAgents;
        }

        /**
         * Answers an aggregate query. For each query point q in agents,
         * computes the aggregate of all of the matching points that fall
         * within the region rg->getRegion(q). These should be reported by
         * calling cb->reportPair() on the query point and its aggregate.
         */
        void aggregateJoin(JoinCallBack<K,U,A>* cb,
                           std::vector<U*>* agents,
                           RG* rg) {
            return;
        }

        /**
         * Answers a knn query. For each query point q in agents, reports the
         * k nearest points from the index in order of increasing
         * distance. Answers are reported using cb->reportPair().
         */
        void nearestKJoin(JoinCallBack<K,U,U>* cb,
                          std::vector<U*>* agents,
                          int k) {
            return;
        }

        /**
         * Updates the aggregate (data) value of a point. This method will be
         * called after the aggregate has been modified in the master copy of
         * the points. Updates to key attributes should be made by deleting
         * the point and then reinserting it.
         */
        void afterUpdateAgg(U* u) {
            //Implement me.
        }

        /**
         * Inserts a point into the index. This method will be called after u
         * has been inserted into the master copy of the points.
         */
        void afterInsert(U* u) {
            //Implement me.
        }

        /**
         * Deletes a point from the index. This method will be called before u
         * has been deleted from the master copy of the points.
         */
        void beforeDelete(U* u) {
            //Implement me.
        }

        /**
         * Performs any end-of-tick cleanup. If force is true, the index must
         * free all memory it holds. If updates are batched, they should be
         * performed here.
         */
        void endTick(bool force = false) {
            //if (force) {
            delete baseAgents;
            sweepStructure->clear();
            //}
        }


        GenericPBSM2D() {

//            this->sweepStructure = new ListSweep<U,K>();
            this->sweepStructure = new StripedSweep<U,K>(32);
            this->tileDim = DEFAULT_TILE_DIM;
            this->numPartitions = tileDim * tileDim;
            sprintf(name, "GenericPBSM%s", sweepStructure->getName());            
        }

        GenericPBSM2D(SweepStructure<U,K>* sweepStruct, 
                      int tileDim,
                      int numPartitions) {
            this->sweepStructure = sweepStruct;
            this->tileDim = tileDim;
            this->numPartitions = numPartitions;
            sprintf(name, "GenericPBSM%s", sweepStructure->getName());            
        }

        ~GenericPBSM2D() {}
    };
}


#endif /* _GENERIC_PBSM_2D_H_ */
